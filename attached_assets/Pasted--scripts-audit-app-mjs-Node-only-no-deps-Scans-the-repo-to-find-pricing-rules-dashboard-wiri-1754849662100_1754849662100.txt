// scripts/audit-app.mjs
// Node-only, no deps. Scans the repo to find pricing/rules/dashboard wiring.
// Outputs audit-report.json you can share back to me to hard-code the same logic.

import fs from "fs";
import path from "path";
import os from "os";

const ROOT = process.cwd();
const OUT = path.join(ROOT, "audit-report.json");

// 1) Where to look
const SEARCH_DIRS = [
  "server",
  "src",
  "app",
  "lib",
  "utils",
  "packages",
  "shared",
].map(p => path.join(ROOT, p)).filter(p => fs.existsSync(p));

// 2) What to look for (feel free to add more tokens)
const TOKENS = [
  // pricing / costing
  "pricing", "cost", "£", "gbp", "quote", "estimate", "rate", "labour", "materials",
  "liner", "patch", "patching", "cipp", "excavate", "excavation", "jetting",
  "root cut", "reline", "point repair", "CIPP", "UV liner",

  // WRc / MSCC / SRM / defects
  "MSCC5", "MSCC", "SRM", "OS19", "OS20", "Drain Repair Book",
  "WRc", "grade", "grades", "PLR", "structural", "service", "operational",
  "WL", "DER", "DES", "JN", "CP", "REF", "FC", "BJ", "CC", "FL", "CMJ", "FCJ", "RMJ",

  // dashboard / UI data plumbing
  "dashboard", "Summary", "Scoring", "Recommendations", "Table",
  "api/reports", "api/sections", "api/observations", "api/recommendations",
  "/api/jobs", "/api/upload",

  // rules/engines
  "rules", "rule", "engine", "mapping", "lookup", "threshold", "weight", "score"
];

// 3) Small helpers
function isCodeFile(file) {
  const ok = [".ts", ".tsx", ".js", ".mjs", ".cjs", ".json"];
  return ok.includes(path.extname(file).toLowerCase());
}

function* walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    if (e.name.startsWith(".") || e.name === "node_modules" || e.name === "dist" || e.name === "build") continue;
    const p = path.join(dir, e.name);
    if (e.isDirectory()) yield* walk(p);
    else if (isCodeFile(p)) yield p;
  }
}

function findTokensInText(text, tokens) {
  const hits = [];
  const lines = text.split(/\r?\n/);
  lines.forEach((line, i) => {
    const lcline = line.toLowerCase();
    const matched = tokens.filter(t => lcline.includes(t.toLowerCase()));
    if (matched.length) {
      // capture a small snippet
      hits.push({
        line: i + 1,
        text: line.trim().slice(0, 240),
        tokens: matched
      });
    }
  });
  return hits;
}

// 4) Attempt to resolve dynamic “known suspects”
const SUSPECT_MODULE_PATHS = [
  // common locations people use for these bits:
  "server/rules",
  "server/wrc",
  "server/pricing",
  "server/services/pricing",
  "server/services/rules",
  "lib/rules",
  "lib/pricing",
  "src/server/rules",
  "src/server/pricing",
  "app/api/rules",
  "app/api/pricing",
].map(p => path.join(ROOT, p));

function safeRequire(p) {
  try {
    return { ok: true, mod: require(p) };
  } catch (e) {
    return { ok: false, error: String(e?.message || e) };
  }
}

// 5) Capture environment that might toggle behaviour
const envSnapshot = Object.fromEntries(
  Object.entries(process.env)
    .filter(([k]) => [
      "NODE_ENV", "DATABASE_URL", "APP_BASE_URL",
      "NEON", "NEON_DATABASE_URL",
      "FALLBACK", "USE_FALLBACK", "DISABLE_AI",
      "STORAGE_BUCKET", "S3_BUCKET", "B2_BUCKET"
    ].some(prefix => k.toUpperCase().includes(prefix)))
);

// 6) Scan all files
const files = [];
for (const dir of SEARCH_DIRS) {
  for (const file of walk(dir)) files.push(file);
}

const findings = [];
for (const file of files) {
  const text = fs.readFileSync(file, "utf8");
  const hits = findTokensInText(text, TOKENS);
  if (hits.length) {
    findings.push({
      file: path.relative(ROOT, file),
      hits: hits.slice(0, 50) // don’t explode output; we only need a sample
    });
  }
}

// 7) Probe “suspect” folders for modules we might import to dump config/rules
const suspects = [];
for (const dir of SUSPECT_MODULE_PATHS) {
  if (!fs.existsSync(dir)) continue;
  const listing = fs.readdirSync(dir);
  const jsLike = listing.filter(f => /\.(m?js|cjs|ts|json)$/.test(f));
  const probe = [];
  for (const f of jsLike) {
    const p = path.join(dir, f);
    // don’t execute arbitrary code; only attempt to require JSON or simple CommonJS safely
    if (p.endsWith(".json")) {
      try {
        probe.push({ file: path.relative(ROOT, p), value: JSON.parse(fs.readFileSync(p, "utf8")) });
      } catch (e) {
        probe.push({ file: path.relative(ROOT, p), error: String(e?.message || e) });
      }
    } else if (p.endsWith(".js") || p.endsWith(".cjs") || p.endsWith(".mjs")) {
      // Best-effort require for plain data exports; ignore failures
      const res = safeRequire(p);
      if (res.ok) {
        // Try to pick out obvious exports
        const mod = res.mod;
        const pick = {};
        for (const k of Object.keys(mod || {})) {
          if (/price|cost|rule|map|mscc|wrc|srm|recommend/i.test(k)) {
            pick[k] = mod[k];
          }
        }
        probe.push({ file: path.relative(ROOT, p), exports: Object.keys(mod || {}), sample: pick });
      } else {
        probe.push({ file: path.relative(ROOT, p), error: res.error });
      }
    } else if (p.endsWith(".ts")) {
      // just index TS files; we don’t compile/execute here
      probe.push({ file: path.relative(ROOT, p), note: "TS file indexed (no execution)" });
    }
  }
  suspects.push({ dir: path.relative(ROOT, dir), probe });
}

// 8) Try to detect dashboard consumers (basic heuristics)
const dashboardConsumers = findings
  .filter(f => /dashboard|summary|table|recommend|api\//i.test(JSON.stringify(f)))
  .map(f => f.file);

// 9) Final report
const report = {
  generatedAt: new Date().toISOString(),
  system: {
    node: process.version,
    platform: `${os.platform()} ${os.arch()}`,
    root: ROOT
  },
  env: envSnapshot,
  search: {
    dirs: SEARCH_DIRS.map(d => path.relative(ROOT, d)),
    tokenCount: TOKENS.length,
    filesScanned: files.length
  },
  findings,
  suspects,
  dashboardConsumers
};

fs.writeFileSync(OUT, JSON.stringify(report, null, 2));
console.log(`✅ Wrote ${path.relative(ROOT, OUT)}`);
console.log(`• Files scanned: ${files.length}`);
console.log(`• Findings with hits: ${findings.length}`);
console.log(`• Suspect folders probed: ${suspects.length}`);
